import {createAccess} from '@refinio/one.core/lib/access.js';
import type {Group, Person} from '@refinio/one.core/lib/recipes.js';
import {SET_ACCESS_MODE} from '@refinio/one.core/lib/storage-base-common.js';
import type {UnversionedObjectResult} from '@refinio/one.core/lib/storage-unversioned-objects.js';
import {storeUnversionedObject} from '@refinio/one.core/lib/storage-unversioned-objects.js';
import {createRandomString} from '@refinio/one.core/lib/system/crypto-helpers.js';
import {calculateHashOfObj, calculateIdHashOfObj} from '@refinio/one.core/lib/util/object.js';
import {serializeWithType} from '@refinio/one.core/lib/util/promise.js';
import type {SHA256IdHash} from '@refinio/one.core/lib/util/type-checks.js';
import {ensureIdHash} from '@refinio/one.core/lib/util/type-checks.js';
import type {IdObjectResult} from '../../misc/ObjectEventDispatcher.js';
import {objectEvents} from '../../misc/ObjectEventDispatcher.js';
import {OEvent} from '../../misc/OEvent.js';
import type {Topic} from '../../recipes/ChatRecipes.js';
import type {ChannelInfo} from '../../recipes/ChannelRecipes.js';
import type ChannelManager from '../ChannelManager.js';
import LeuteModel from '../Leute/LeuteModel.js';
import {Model} from '../Model.js';
import TopicRegistry from './TopicRegistry.js';
import TopicRoom from './TopicRoom.js';
import {createMessageBus} from '@refinio/one.core/lib/message-bus.js';

const MessageBus = createMessageBus('TopicModel');

/**
 * Model that manages the creation of chat topics.
 */
export default class TopicModel extends Model {
    /**
     * Notify the user whenever a new topic is created or received.
     */
    public onNewTopicEvent = new OEvent<() => void>();

    private readonly channelManager: ChannelManager;
    private readonly leuteModel: LeuteModel;
    private readonly TopicRegistryLOCK = 'ON_TOPIC_REGISTRY_OPERATION';
    private topicRegistry: TopicRegistry | undefined;
    private disconnectFns: Array<() => void> = [];

    constructor(channelManager: ChannelManager, leuteModel: LeuteModel) {
        super();
        this.channelManager = channelManager;
        this.leuteModel = leuteModel;
    }

    /**
     * Register listeners.
     */
    public async init(): Promise<void> {
        this.state.assertCurrentState('Uninitialised');
        
        // Additional diagnostic logging
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init starting`);
        
        if (this.channelManager === undefined || this.leuteModel === undefined) {
            MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init ERROR - Required dependencies not provided: channelManager=${this.channelManager ? 'defined' : 'undefined'}, leuteModel=${this.leuteModel ? 'defined' : 'undefined'}`);
            throw new Error('ChannelManager or LeuteModel are not set.');
        }

        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - Loading topic registry`);
        this.topicRegistry = await TopicRegistry.load();

        // Set up debug for the new topic event
        this.onNewTopicEvent.setEventName('TopicModel.onNewTopicEvent');
        this.onNewTopicEvent.enableDebug(true);

        // Debug - verify access to channel manager
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - Setting up listener for channel updates`);
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - Current listener count on channelManager.onUpdated: ${this.channelManager.onUpdated.listenerCount()}`);
        
        // Add a diagnostic listener to verify channel events are working
        const diagnosticListener = this.channelManager.onUpdated((channelInfoIdHash, channelId, channelOwner, timeOfEarliestChange, data) => {
            MessageBus.send('debug', `[DIAGNOSTIC] Received channel update in DIAGNOSTIC listener: channelId=${channelId}, hash=${channelInfoIdHash}`);
        });
        
        MessageBus.send('debug', `[DIAGNOSTIC] Added direct diagnostic listener to ChannelManager.onUpdated`);
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - New listener count: ${this.channelManager.onUpdated.listenerCount()}`);
        
        // Register our main listeners
        this.disconnectFns.push(
            // Main channel listener that queries topic registry
            this.channelManager.onUpdated((channelInfoIdHash, channelId) => {
                MessageBus.send('debug', `[TOPIC_EVENT] Topic handle channel update: ${channelId}, ${channelInfoIdHash}`);
                this.topicRegistry?.queryById(channelId);
            }),
            
            // Original listeners for monitoring events
            objectEvents.onUnversionedObject(
                async (result) => {
                    if (result.obj.$type$ === 'Topic') {
                        MessageBus.send('debug', `[TOPIC_EVENT] Processing new Topic object - id: ${result.obj.id}`);
                        await this.addTopicToRegistry(result);
                    }
                },
                'TopicModel: addTopicToRegistry',
                'Topic'
            ),
            
            // Group listener for everyone topics
            objectEvents.onNewIdObject(
                this.shareEveryoneTopics.bind(this),
                'TopicModel: shareEveryoneTopics',
                'Group'
            )
        );
        
        // Diagnostic logging of listeners to ensure proper registration
        if (typeof this.disconnectFns[0] === 'function') {
            MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - Successfully registered channel update listener`);
        } else {
            MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init ERROR - Failed to register channel update listener`);
        }
        
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init - Final listener count: ${this.channelManager.onUpdated.listenerCount()}`);
        
        this.state.triggerEvent('init');
        MessageBus.send('debug', `[TOPIC_EVENT] TopicModel.init complete`);
    }

    /**
     * De-register the listeners.
     */
    async shutdown(): Promise<void> {
        this.state.assertCurrentState('Initialised');
        this.state.triggerEvent('shutdown');

        for (const disconnectFn of this.disconnectFns) {
            disconnectFn();
        }
        this.disconnectFns = [];
        this.topicRegistry = undefined;
    }

    /**
     * Retrieves the topic registry. Omit the add & remove functions from the public API. The model
     * takes care of those things.
     */
    public get topics(): Omit<TopicRegistry, 'add' | 'remove'> {
        this.state.assertCurrentState('Initialised');

        // assertCurrentState ensures that the model was initialised - so topics are not undefined
        const topicRegistry = this.topicRegistry as TopicRegistry;

        return {
            all: topicRegistry.all,
            queryById: topicRegistry.queryById,
            queryHashById: topicRegistry.queryHashById,
            queryByName: topicRegistry.queryByName
        };
    }

    /**
     * Enter the topic room by the given topic channel id.
     * @param topicID
     */
    public async enterTopicRoom(topicID: string): Promise<TopicRoom> {
        this.state.assertCurrentState('Initialised');

        if (this.topicRegistry === undefined) {
            throw new Error('Error while retrieving topic registry, model not initialised.');
        }

        const foundTopic = await this.topicRegistry.queryById(topicID);

        if (foundTopic === undefined) {
            throw new Error('Error while trying to retrieve the topic. The topic does not exist.');
        }

        return new TopicRoom(foundTopic, this.channelManager, this.leuteModel);
    }

    /**
     * Creates group topic (multiplePerson)
     * @param topicName
     */
    public async createGroupTopic(
        topicName: string,
        topicId?: string,
        channelOwner?: SHA256IdHash<Person>
    ): Promise<Topic> {
        this.state.assertCurrentState('Initialised');

        return await this.createNewTopic(topicName, topicId, channelOwner);
    }

    /**
     * Share the given topic with the desired persons.
     * @param participants
     * @param topic
     */
    public async addPersonsToTopic(
        participants: SHA256IdHash<Person>[],
        topic: Topic
    ): Promise<void> {
        await createAccess([
            {
                id: topic.channel,
                person: participants,
                group: [],
                mode: SET_ACCESS_MODE.ADD
            }
        ]);
        await createAccess([
            {
                object: await calculateHashOfObj(topic),
                person: participants,
                group: [],
                mode: SET_ACCESS_MODE.ADD
            }
        ]);
    }

    /**
     * Share the given topic with the desired group.
     * @param groupIdHash
     * @param topic
     */
    public async addGroupToTopic(groupIdHash: SHA256IdHash<Group>, topic: Topic): Promise<void> {
        await createAccess([
            {
                id: topic.channel,
                person: [],
                group: [groupIdHash],
                mode: SET_ACCESS_MODE.ADD
            }
        ]);
        await createAccess([
            {
                object: await calculateHashOfObj(topic),
                person: [],
                group: [groupIdHash],
                mode: SET_ACCESS_MODE.ADD
            }
        ]);
    }

    // ######## Everyone chat stuff ########
    // Note that the everyone chat is just a temporary thing until we resolved some kinks in the
    // generic topics.

    public static readonly EVERYONE_TOPIC_ID = 'EveryoneTopic';
    public static readonly GLUE_TOPIC_ID = 'GlueOneTopic';

    /**
     * Creates the default everyone topic if it does not exist.
     *
     * Note: Access rights will be automatically given to the "leute everyone" group by the
     * addTopicToRegistry hook, that listens for new Topic objects.
     */
    public async createEveryoneTopic(): Promise<Topic> {
        return this.createNewTopic('Everyone', TopicModel.EVERYONE_TOPIC_ID);
    }

    /**
     * Creates the one.glue topic if it does not exist.
     *
     * Note: Access rights will be automatically given to the "leute everyone" group by the
     * addTopicToRegistry hook, that listens for new Topic objects.
     */
    public async createGlueTopic(): Promise<Topic> {
        return this.createNewTopic('glue.one', TopicModel.GLUE_TOPIC_ID);
    }

    /**
     * Return whether the topicId refers to the everyone chat or not.
     *
     * @param topicId
     */
    public isEveryoneChat(topicId: string): boolean {
        return topicId === TopicModel.EVERYONE_TOPIC_ID;
    }

    /**
     * Return whether the topicId refers to the one.glue chat or not.
     *
     * @param topicId
     */
    public isGlueChat(topicId: string): boolean {
        return topicId === TopicModel.GLUE_TOPIC_ID;
    }

    /**
     * Shares the topic and channel with the person that participate in this 1:1 chat.
     *
     * @param topic
     */
    private async applyAccessRightsIfEveryoneChat(topic: Topic): Promise<void> {
        if (!this.isEveryoneChat(topic.id) && !this.isGlueChat(topic.id)) {
            return;
        }

        const everyoneGroupModel = (await this.leuteModel.groups()).find(
            groupModel => groupModel.name === LeuteModel.EVERYONE_GROUP_NAME
        );

        if (everyoneGroupModel !== undefined) {
            await this.addGroupToTopic(everyoneGroupModel.groupIdHash, topic);
        }
    }

    // ######## One To One chat stuff ########
    // Note that 1:1 chats are just a temporary thing until we resolved some kinks in the
    // generic topics.

    private static readonly oneToOneTopicRegexp = /^([0-9a-f]{64})<->([0-9a-f]{64})$/;

    /**
     * Creates one to one topic (person to person)
     *
     * Note: Access rights will be automatically given to the participants by the
     * addTopicToRegistry hook, that listens for new Topic objects.
     *
     * @param from
     * @param to
     * @param channelOwner Optional. One of `from`, `to` or undefined (default)
     */
    public async createOneToOneTopic(
        from: SHA256IdHash<Person>,
        to: SHA256IdHash<Person>,
        channelOwner?: SHA256IdHash<Person>
    ): Promise<Topic> {
        this.state.assertCurrentState('Initialised');

        const nameAndId = [from, to].sort().join('<->');
        const owner = channelOwner === from || channelOwner === to ? channelOwner : undefined;
        return await this.createNewTopic(nameAndId, nameAndId, owner);
    }

    /**
     * Return whether the topicId refers to a 1:1 chat or not.
     *
     * @param topicId
     */
    public isOneToOneChat(topicId: string): boolean {
        return TopicModel.oneToOneTopicRegexp.test(topicId);
    }

    /**
     * Get participants of a 1:1 topic.
     *
     * @param topicId
     */
    public getOneToOneChatParticipants(
        topicId: string
    ): [SHA256IdHash<Person>, SHA256IdHash<Person>] {
        const m = topicId.match(TopicModel.oneToOneTopicRegexp);

        if (m === null || m.length !== 3) {
            throw new Error('This is not a OneToOne Chat');
        }

        return [ensureIdHash<Person>(m[1]), ensureIdHash<Person>(m[2])];
    }

    /**
     * Get participants of a 1:1 topic, but return my identity first if I am a participant.
     *
     * @param topicId
     */
    public async getOneToOneChatParticipantsMeFirst(
        topicId: string
    ): Promise<[SHA256IdHash<Person>, SHA256IdHash<Person>]> {
        let [meHash, otherHash] = this.getOneToOneChatParticipants(topicId);

        const myIds = await this.leuteModel.me();

        if (myIds.identities().includes(otherHash)) {
            [meHash, otherHash] = [otherHash, meHash];
        }

        return [meHash, otherHash];
    }

    /**
     * Shares the topic and channel with the person that participate in this 1:1 chat.
     *
     * @param topic
     */
    private async applyAccessRightsIfOneToOneChat(topic: Topic): Promise<void> {
        if (!this.isOneToOneChat(topic.id)) {
            return;
        }
        const participants = this.getOneToOneChatParticipants(topic.id);
        await this.addPersonsToTopic(participants, topic);
    }

    // --------------------------------- private ---------------------------------

    /**
     * Verifies that a channel exists in the cache with exponential backoff
     * @param channelInfoIdHash - The channel ID hash to verify
     * @param maxAttempts - Maximum number of attempts (default 10)
     * @param baseDelay - Base delay in milliseconds (default 100ms)
     */
    private async verifyChannelInCache(
        channelInfoIdHash: SHA256IdHash<ChannelInfo>,
        maxAttempts: number = 10,
        baseDelay: number = 100
    ): Promise<void> {
        const startTime = Date.now();
        
        // Get system owner as default
        const systemOwner = await calculateIdHashOfObj({ 
            $type$: 'Person', 
            email: 'system@lama.local' 
        }) as SHA256IdHash<Person>;
        
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                // First check if channel exists
                const channelExists = await this.channelManager.hasChannel(channelInfoIdHash, systemOwner);
                if (channelExists) {
                    // Then verify we can get channel info
                    const channelInfo = await this.channelManager.getChannelInfo(channelInfoIdHash);
                    if (channelInfo) {
                        return;
                    }
                }
            } catch (error) {
                // Log error but continue retrying
                console.error('[TopicModel] Error verifying channel:', {
                    attempt,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    channelInfoIdHash,
                    elapsed: Date.now() - startTime
                });
            }

            // Exponential backoff with jitter
            const delay = baseDelay * Math.pow(2, attempt) * (0.9 + Math.random() * 0.2);
            await new Promise(resolve => setTimeout(resolve, delay));
        }

        throw new Error(`Channel creation failed: Channel not found in cache after ${maxAttempts} attempts over ${Date.now() - startTime}ms`);
    }

    /**
     * Creates a new topic with proper synchronization to prevent race conditions.
     * This implementation ensures proper flow control without polling or retries.
     * 
     * @param desiredTopicName - Optional name for the topic, random if not provided
     * @param desiredTopicID - Optional ID for the topic, random if not provided
     * @param channelOwner - Optional owner for the channel
     */
    private async createNewTopic(
        desiredTopicName?: string,
        desiredTopicID?: string,
        channelOwner?: SHA256IdHash<Person>
    ): Promise<Topic> {
        MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic START - name: ${desiredTopicName}, id: ${desiredTopicID}, owner: ${channelOwner ? channelOwner : 'null'}`);
        
        this.state.assertCurrentState('Initialised');
        if (this.topicRegistry === undefined) {
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic ERROR - topic registry not initialized`);
            throw new Error('Error while retrieving topic registry, model not initialised.');
        }

        // if no name was passed, generate a random one
        const topicName =
            desiredTopicName === undefined ? await createRandomString() : desiredTopicName;
        // generate a random channel id
        const topicID = desiredTopicID === undefined ? await createRandomString() : desiredTopicID;

        MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - using topic name: ${topicName}, id: ${topicID}`);

        // Check if topic already exists and then return
        MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - checking if topic already exists: ${topicID}`);
        const foundTopic = await this.topicRegistry.queryById(topicID);
        if (foundTopic) {
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - topic already exists, returning existing topic: ${topicID}`);
            return foundTopic;
        }

        // Get a reference to the registry to ensure it exists throughout the operation
        const registry = this.topicRegistry;
        if (!registry) {
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic ERROR - topic registry became undefined during creation`);
            throw new Error('Topic registry became undefined during topic creation');
        }

        // Serialize all registry operations to prevent race conditions
        MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - serializing registry operations with lock: ${this.TopicRegistryLOCK}`);
        return await serializeWithType(this.TopicRegistryLOCK, async () => {
            // Create a promise that resolves when the channel is updated
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - setting up channelUpdatePromise for channelId: ${topicID}`);
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - current listener count on channelManager.onUpdated: ${this.channelManager.onUpdated.listenerCount()}`);
            
            const channelUpdatePromise = new Promise<SHA256IdHash<ChannelInfo>>((resolve) => {
                MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] channelUpdatePromise - registering onUpdated listener for channelId: ${topicID}`);
                const cleanup = this.channelManager.onUpdated((channelInfoIdHash, channelId, owner, time, data) => {
                    MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] channelUpdatePromise - received update event, channelId: ${channelId}, topicID: ${topicID}, match: ${channelId === topicID}`);
                    if (channelId === topicID) {
                        MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] channelUpdatePromise - channelId matches, cleaning up and resolving with: ${channelInfoIdHash}`);
                        cleanup();
                        resolve(channelInfoIdHash);
                    }
                });
                MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] channelUpdatePromise - listener registered, new count: ${this.channelManager.onUpdated.listenerCount()}`);
            });

            // Create the channel and wait for the update event
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - calling channelManager.createChannel with id: ${topicID}, owner: ${channelOwner ? channelOwner : 'null'}`);
            await this.channelManager.createChannel(topicID, channelOwner ? channelOwner : null);
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - createChannel returned, waiting for channelUpdatePromise to resolve`);
            
            const channelInfoIdHash = await channelUpdatePromise;
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - channelUpdatePromise resolved with: ${channelInfoIdHash}`);

            // Store the topic
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - storing topic: ${topicName}, id: ${topicID}, channel: ${channelInfoIdHash}`);
            const savedTopic = await storeUnversionedObject({
                $type$: 'Topic',
                id: topicID,
                channel: channelInfoIdHash,
                name: topicName
            });
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - topic stored successfully`);

            // Add to registry within the same atomic operation
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - adding topic to registry: ${topicID}`);
            await registry.add(savedTopic);
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - topic added to registry`);

            // Apply access rights within the same atomic operation
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - applying access rights for 1:1 chat`);
            await this.applyAccessRightsIfOneToOneChat(savedTopic.obj);
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - applying access rights for everyone chat`);
            await this.applyAccessRightsIfEveryoneChat(savedTopic.obj);

            // Verify topic is in registry before returning
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - verifying topic in registry: ${topicID}`);
            const verifiedTopic = await registry.queryById(topicID);
            if (!verifiedTopic) {
                MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic ERROR - failed to verify topic in registry: ${topicID}`);
                throw new Error('Topic creation failed: Topic not found in registry after creation');
            }

            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic - emitting onNewTopicEvent`);
            this.onNewTopicEvent.emit();
            MessageBus.send('debug', `[TOPIC_EVENT_DETAILED] createNewTopic COMPLETE - topic created: ${topicID}`);
            return savedTopic.obj;
        });
    }

    private async shareEveryoneTopics(result: IdObjectResult<Group>): Promise<void> {
        if (result.obj.name === LeuteModel.EVERYONE_GROUP_NAME && result.status === 'new') {
            const everyoneTopic = await this.topics.queryById(TopicModel.EVERYONE_TOPIC_ID);
            const glueTopic = await this.topics.queryById(TopicModel.GLUE_TOPIC_ID);

            if (everyoneTopic !== undefined) {
                await this.addGroupToTopic(result.idHash, everyoneTopic);
            }

            if (glueTopic !== undefined) {
                await this.addGroupToTopic(result.idHash, glueTopic);
            }
        }
    }

    /**
     * This adds the topic to the registry and notifies the user of a new topic and also sets up
     * the sharing.
     *
     * @param result
     */
    private async addTopicToRegistry(result: UnversionedObjectResult<Topic>): Promise<void> {
        const topic = result.obj;
        
        MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Starting for topic id: ${topic.id}, channel: ${topic.channel}`);

        await serializeWithType(this.TopicRegistryLOCK, async () => {
            if (this.topicRegistry === undefined) {
                MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - ERROR: Topic registry not initialized`);
                throw new Error('Error while retrieving topic registry, model not initialised.');
            }

            MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Adding topic to registry: ${topic.id}`);
            await this.topicRegistry.add(result);
            
            MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Applying access rights for 1:1 chat if needed`);
            await this.applyAccessRightsIfOneToOneChat(topic);
            
            MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Applying access rights for everyone chat if needed`);
            await this.applyAccessRightsIfEveryoneChat(topic);
            
            MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - About to emit onNewTopicEvent, listeners: ${this.onNewTopicEvent.listenerCount()}`);
            this.onNewTopicEvent.emit();
            MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Emitted onNewTopicEvent`);
        });
        
        MessageBus.send('debug', `[TOPIC_EVENT] addTopicToRegistry - Completed for topic id: ${topic.id}`);
    }
}
