/**
 * @author Michael Hasenstein <hasenstein@yahoo.com>
 * @copyright REFINIO GmbH 2017
 * @license CC-BY-NC-SA-2.5; portions MIT License
 * @version 0.0.1
 */

/**
 * This module handles incoming WebSocket messages received in response to requests sent by us.
 * Those messages either fulfill an open promise waiting for a result from the remote side, or
 * they are part of a file stream (base64 encoded string or binary).
 * @private
 * @module
 */

/**
 * This function is generated by
 * {@link websocket-response-handler.module:ts.createHandler|`websocket-response-handler.createHandler`} which binds a `requests` Map-object and a `streams` Map-object in this function's outer scope.
 * @typedef {Function} WebsocketBinaryMessageHandler
 * @param {ArrayBufferLike | Uint8Array} chunk - Binary buffer received from the communication partner
 * @returns {undefined} Returns nothing (event handler).
 */
export type WebsocketBinaryMessageHandler = (chunk: ArrayBufferLike | Uint8Array) => void;

/**
 * This function is generated by
 * {@link websocket-response-handler.module:ts.createHandler|`websocket-response-handler:createHandler`} which binds a `requests` Map object and a `streams` Map-object in this function's outer scope.
 * @typedef {Function} WebsocketMessageResponseHandler
 * @param {object} msg - Message object received from the communication partner with the response
 * to a request we sent
 * @returns {undefined} Returns nothing. The actual "return" value is the received response
 * (data or error), which is used to resolve (or reject) the promise for the given responseId
 * (a.k.a. request ID when we sent it).
 */
export type WebsocketMessageResponseHandler = (msg: MsgResponseTypes) => void;

/**
 * @typedef {object} WebsocketResponseHandler
 * @property {WebsocketBinaryMessageHandler} binaryResponseMsgHandler
 * @property {WebsocketMessageResponseHandler} jsonResponseMsgHandler
 * @property {function():void} cancelWriteStreams
 */
export interface WebsocketResponseHandler {
    binaryResponseMsgHandler: WebsocketBinaryMessageHandler;
    jsonResponseMsgHandler: WebsocketMessageResponseHandler;
    cancelWriteStreams: () => void;
}

import {createError, type ErrorWithCode} from './errors.js';
import {createMessageBus} from './message-bus.js';
import type {BLOB} from './recipes.js';
import type {FileCreation, SimpleWriteStream} from './storage-base-common.js';
import {createFileWriteStream} from './system/storage-streams.js';
import {getArrayBuffer} from './util/buffer.js';
import {isFunction, isObject} from './util/type-checks-basic.js';
import type {
    MsgRequestErrorObject,
    MsgRequestTypes,
    MsgResponseStreamEndObject,
    MsgResponseStreamErrorObject,
    MsgResponseStreamObject,
    MsgResponseTypes,
    RequestData
} from './websocket-promisifier.js';

const MessageBus = createMessageBus('websocket-request-handler');

/**
 * Creates a zero-length file - so it will always be a constant hash. This is for the edge case
 * where a zero-length BLOB is transferred.
 * @private
 * @async
 * @returns {Promise<FileCreation>}
 */
async function createZeroLengthFile(): Promise<FileCreation<BLOB>> {
    const stream = createFileWriteStream();
    stream.write(new ArrayBuffer(0));
    return await stream.end();
}

/**
 * @static
 * @param {Map<number,Function[]>} requests - Map: Request ID => [resolve,reject]
 * function for the promise for the given request
 * @param {function((MsgRequestTypes|MsgResponseTypes)):undefined} sendObj
 * @returns {{binaryMsgHandler:Function,jsonMsgHandler:Function,onWsClose:Function}}
 * Returns an object with two message handler functions and a helper function to cancel all open
 * write streams for this connection
 */
export function createResponseHandler(
    requests: Map<number, RequestData>,
    sendObj: (data: MsgRequestTypes | MsgResponseTypes) => void
): WebsocketResponseHandler {
    /**
     * INNER SCOPE -- THIS IS PER WEBSOCKET
     *
     * Binary messages always are (are should be) responses to requests we sent (instead of
     * requests we receive). The request ID is expected to be encoded as a 64 bit Javascript
     * number (IEEE 754 Double-precision floating-point format) in the first 8 bytes of the
     * binary chunk, using LE endianness. Binary streams may come in chunks and need to be
     * assembled. If there isn't an entry and therefore an existing write-stream for a
     * previously received chunk a new one is created and added to this map. When a
     * (non-binary, JSON-encoded) message arrives for the same request ID telling us that we
     * received all chunks (websocket messages arrive here in-order, regardless of network
     * order) we can end the write-stream and remove the entry from the Map.
     * NULL: The special value null is used to mark streams that caused an error.
     * @private
     * @type {Map<number, null | SimpleWriteStream>}
     */
    const streams: Map<number, null | SimpleWriteStream> = new Map();

    /**
     * Creates a write-stream and saves it in the Map of active write streams.
     * @private
     * @param {number} responseId - The responseId (and therefore the requestId) the stream
     * belongs to
     * @param {('base64'|'utf8')} [encoding] - 'utf8' for text file streams or 'base64' for base64
     * encoded string streams, `undefined` for binary streams
     * @returns {SimpleWriteStream}
     */
    function createAndRegisterWriteStream<E extends undefined | 'base64' | 'utf8'>(
        responseId: number,
        encoding?: E
    ): SimpleWriteStream<E> {
        if (streams.get(responseId) !== undefined) {
            // This should be impossible, but since the impossible could always happen...
            throw createError('WSRQ-CWRST1', {responseId});
        }

        const stream = createFileWriteStream(encoding);

        streams.set(responseId, stream);

        stream.promise.catch(err => {
            // The write-stream automatically cancels itself when an error occurs
            // NO DELETION: There may still be chunks of this stream on their way, so we cannot
            // simply remove the entry
            streams.set(responseId, null);

            // This is special and needs special handling by the other party too: This message is
            // neither a request nor a response to one. We send it so that the other party knows
            // they should stop sending more messages - after an error we cannot continue
            // writing to the write-stream and would have to throw away any further chunks of the
            // stream.
            // This message will be received and interpreted by the websocket-request-handler
            // module's request handler function.
            sendObj({
                // These special messages use "requestId" so that they end up in the request
                // handler that serves the requested stream that caused this error, so that
                // it can stop the stream. If we used "responseId" the message would go to
                // the response handler, which does not know the stream.
                requestId: responseId,
                type: 'write-stream-error'
            } as MsgRequestErrorObject);

            const [, , reject] = requests.get(responseId) ?? [];

            // The probability of this error is significantly increased by delaying the lookup
            // until an error occurs, instead of in the outer scope when the write-stream is
            // created. However, it would be a false sense of safety - at this point in time the
            // entry *should* still exist.
            if (!isFunction(reject)) {
                return MessageBus.send(
                    'alert',
                    'Stream error for already deleted request: ' + responseId
                );
            }

            // The file transfer request was issued from our side, but since we cannot write the
            // response it has to fail
            reject(err);
        });

        return stream;
    }

    /**
     * @instance
     * @function
     * @param {ArrayBufferLike | Uint8Array} msg - The binary message in the buffer contains the responseId and
     * the actual binary stream chunk
     * @returns {undefined} Websocket message (event) handler function: returns nothing
     */
    function binaryResponseMsgHandler(msg: ArrayBufferLike | Uint8Array): void {
        // The binary chunk consists of 8 bytes "number" and the rest is the actual data
        const responseId = new Float64Array(getArrayBuffer(msg), 0, 1)[0];

        let stream = streams.get(responseId);

        if (stream === undefined) {
            stream = createAndRegisterWriteStream(responseId);
        }

        // Ignore the message if this is a stream that caused an error (on our side) - we
        // received this chunk because the sender was not yet aware of the problem on our side
        // and kept sending.
        if (stream !== null) {
            stream.write(getArrayBuffer(msg).slice(8));
        }
    }

    /**
     * A chunk of a string-based base64 stream (binary chunks are handled by the binary handler)
     * @private
     * @instance
     * @param {MsgResponseObject} msg
     * @returns {undefined}
     */
    function stringStreamResponseHandler(msg: Readonly<MsgResponseStreamObject>): void {
        let stream = streams.get(msg.responseId);

        // undefined: This is the first chunk of a requested file
        // null: This is a chunk of a file which encountered an error on our side when we
        //    tried to write an earlier chunk. The remote site may still have sent more
        //    chunks before receiving our error notification to stop the stream.
        if (stream === undefined) {
            stream = createAndRegisterWriteStream(msg.responseId, msg.encoding);
        }

        // Ignore the message if this is a stream that caused an error (on our side) - we
        // received this chunk because the sender was not yet aware of the problem on our side
        // and kept sending.
        if (stream !== null) {
            // Type refinement was done before calling this function
            stream.write(msg.chunk);
        }
    }

    /**
     * Signals the end of BOTH binary or string-based streams - with error or not
     * @private
     * @instance
     * @param {(MsgResponseStreamEndObject|MsgResponseStreamErrorObject)} msg
     * @returns {undefined}
     */
    function streamEndResponseHandler(
        msg: Readonly<MsgResponseStreamEndObject | MsgResponseStreamErrorObject>
    ): void {
        const responseId = msg.responseId;

        const [, resolve, reject] = requests.get(responseId) ?? [];

        if (!isFunction(resolve) || !isFunction(reject)) {
            return MessageBus.send(
                'alert',
                'Received response for non-existent request: ' + JSON.stringify(msg)
            );
        }

        const stream = streams.get(responseId);

        // This is valid for zero-length files, which don't have a "data" event, so the "end"
        // stream event is the only one. A write-stream is created when stream data arrives, if no
        // data was sent no write-stream was created.
        if (!isObject(stream)) {
            requests.delete(responseId);

            if (msg.type === 'stream-error') {
                return reject(createError('WSRQ-SEH1', {msg}));
            }

            // Write zero-length file, does not matter should one already exist.
            // NO AWAIT - Runs asynchronously to current (synchronous) function
            createZeroLengthFile()
                .then(resolve)
                .catch(err => reject(err));

            return;
        }

        // The normal end of the stream, or is it a forced ending due to error?
        if (msg.type === 'stream-error') {
            reject(createError('WSRQ-SEH1', {msg}));

            // With "catch()": Handle the promise completely. There is nobody to return it to.
            stream.cancel().catch(err => {
                // Error trying to cancel the write-stream:
                // At this point informing the other party would be futile - for them the
                // stream request was already over when they sent this last message.
                reject(err);
            });
        } else {
            // Asynchronous and decoupled from the rest of the current function
            stream
                .end()
                .then(resolve)
                .catch(err => {
                    // Error trying to normally end the write-stream:
                    // At this point informing the other party would be futile - for them the
                    // stream request was already over when they sent this last message
                    reject(err);
                });
        }

        streams.delete(responseId);

        // Since websocket messages unlike IP packets are received in-order we can be sure
        // that there will be no more messages for this ID of a stream request
        requests.delete(responseId);
    }

    /**
     * @instance
     * @function
     * @param {object} msg - A message object parsed from a JSON string message received on the
     * WebSocket
     * @returns {undefined} Websocket message (event) handler function: returns nothing
     */
    function jsonResponseMsgHandler(msg: MsgResponseTypes): void {
        const [, resolve, reject] = requests.get(msg.responseId) ?? [];

        // THIS CHECK COMES BEFORE THE STREAM FUNCTIONS: Otherwise we could react to (malicious)
        // stream response data which we never requested, writing data to storage that we did
        // not ask for.
        if (!isFunction(resolve) || !isFunction(reject)) {
            return MessageBus.send(
                'alert',
                'Received response for non-existent request: ' + JSON.stringify(msg)
            );
        }

        if (msg.type === 'stream') {
            // Base64 encoded stream
            return stringStreamResponseHandler(msg);
        }

        if (msg.type === 'stream-end' || msg.type === 'stream-error') {
            return streamEndResponseHandler(msg);
        }

        if (msg.type === 'error') {
            const err = createError('WSRQ-JRMH1', {name: 'WebsocketRequestError'});
            const cause = new Error(msg.error.message) as ErrorWithCode;
            cause.name = msg.error.name || cause.name;
            cause.code = msg.error.code;
            err.cause = cause;
            reject(err);
        } else {
            // Resolve the pending request promise with the response we got - the type is unknown
            // to us, we cannot do any checks here. The communicating parties must do their checks
            // in the code that calls this low-level communication module.
            resolve(msg.data);
        }

        // Once fulfilled, there is no need to keep this entry. For non-stream requests a single
        // request message is followed by a single response message. If there was an error
        // serving the request it will be in the response.
        requests.delete(msg.responseId);
    }

    /**
     * Cancels all open write-streams *for the given WebSocket*.
     * @instance
     * @function
     * @returns {undefined}
     */
    function cancelWriteStreams(): void {
        streams.forEach((stream, requestId) => {
            if (stream !== null) {
                stream.cancel().catch(_ => undefined);
                // Not needed if the websocket was closed, but let's do it anyway because it's the
                // clean thing to do and after some now unforeseen code changes elsewhere later
                // this may be needed
                streams.set(requestId, null);
            }
        });
    }

    return {
        binaryResponseMsgHandler,
        jsonResponseMsgHandler,
        cancelWriteStreams
    };
}
