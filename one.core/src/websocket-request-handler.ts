/**
 * @author Michael Hasenstein <hasenstein@yahoo.com>
 * @copyright REFINIO GmbH 2018
 * @license CC-BY-NC-SA-2.5; portions MIT License
 * @version 0.0.1
 */

/**
 * This module handles incoming Websocket messages that are requests to us (we did not ask the
 * other side for those messages).
 * @private
 * @module
 */

/**
 * This function is generated by
 * {@link websocket-response-handler.module:ts.createHandler|`websocket-response-handler:createHandler`}
 * @typedef {Function} WebsocketMessageRequestHandler
 * @param {MsgRequestObject} msg - Message object received from the communication partner with the
 * response to a request we sent
 * @returns {undefined} Returns nothing. The actual "return" value is the received response
 * (data or error), which is used to resolve (or reject) the promise for the given responseId
 * (a.k.a. request ID when we sent it).
 */
export type WebsocketMessageRequestHandler = (msg: MsgRequestTypes) => void;

/**
 * @typedef {object} WebsocketRequestHandler
 * @property {WebsocketMessageRequestHandler} requestMsgHandler
 * @property {function():void} cancelReadStreams
 */
export interface WebsocketRequestHandler {
    requestMsgHandler: WebsocketMessageRequestHandler;
    cancelReadStreams: () => void;
}

/**
 * The type of the function returned by {@link createReadStreamHandler}
 * @private
 * @typedef {Function} ReadStreamHandler
 * @param {MsgRequestObject} msg
 * @param {SimpleReadStream} stream
 * @returns {undefined} Returns `undefined`
 */
type ReadStreamHandler = (msg: MsgRequestObject, stream: SimpleReadStream) => void;

import {createError} from './errors.js';
import {createMessageBus} from './message-bus.js';
import type {SimpleReadStream} from './storage-base-common.js';
import {getUint8Array} from './util/buffer.js';
import {isFunction, isObject, isString} from './util/type-checks-basic.js';
import {isSimpleReadStream} from './util/type-checks.js';
import type {
    EncryptedConnectionInterface,
    FindServiceByChannelAndId,
    MsgRequestObject,
    MsgRequestTypes,
    MsgResponseErrorObject,
    MsgResponseObject,
    MsgResponseStreamEndObject,
    MsgResponseStreamErrorObject,
    MsgResponseStreamObject,
    MsgResponseTypes
} from './websocket-promisifier.js';
import {isSharedArrayBufferSupported} from './util/feature-detection.js';

const MessageBus = createMessageBus('websocket-request-handler');

/**
 * Paused read streams are told to resume when the websocket's bufferedAmount number of bytes
 * falls below this value. Default: 8192 = 8 kBytes
 * @private
 */
const STREAM_LOW_WATER_MARK = 8192;

/**
 * If a read-stream is paused this number of milliseconds is the interval in milliseconds between
 * checks if the stream should be resumed. Default: 100 ms
 * @private
 */
const PAUSED_STREAM_CHECK_INTERVAL = 100;

/**
 * When the websocket's bufferedAmount number of bytes rises above this value the read stream
 * is told to pause. Default: 262144 = 256 kBytes
 * @private
 */
const STREAM_HIGH_WATER_MARK = 262144;

export const UNKNOWN_SERVICE = 'UNKNOWN-SERVICE';

/**
 * Create a function that handles requests that result in a SimpleReadStream. The handler
 * function receives the Websocket and a reference to the per-Websocket Map of streams in its
 * outer lexical scope. The returned handler function is called for each response on this
 * websocket that requires sending a read stream response to the other party, either as utf8
 * or base64 encoded string chunks or as binary chunks.
 * @private
 * @function
 * @param {EncryptedConnectionInterface} connection - The connection to send results to
 * @param {function((MsgRequestTypes|MsgResponseTypes)):undefined} sendObj
 * @param {function(ArrayBuffer):undefined} sendBuf
 * @param {Map<number,SimpleReadStream>} streams - MUTATED! Entries are added and removed.
 * @returns {ReadStreamHandler} Returns a {@link ReadStreamHandler} for SimpleReadStream results.
 */
function createReadStreamHandler(
    connection: EncryptedConnectionInterface,
    sendObj: (data: MsgRequestTypes | MsgResponseTypes) => void,
    sendBuf: (data: ArrayBuffer) => void,
    streams: Map<number, SimpleReadStream>
): ReadStreamHandler {
    return (msg: MsgRequestObject, stream: SimpleReadStream): void => {
        function resumeWhenBufferDrained(): void {
            if (connection.bufferedAmount < STREAM_LOW_WATER_MARK) {
                stream.resume();
            } else {
                setTimeout(resumeWhenBufferDrained, PAUSED_STREAM_CHECK_INTERVAL);
            }
        }

        function onStringStreamData(chunk: string): void {
            sendObj({
                responseId: msg.requestId,
                type: 'stream',
                chunk,
                encoding: encodingSent
                    ? undefined
                    : // "Overly clever code", comma expression, resolves with 2nd
                      // expression
                      ((encodingSent = true), stream.encoding)
            } as MsgResponseStreamObject);
        }

        function onBinaryStreamData(chunk: ArrayBufferLike | Uint8Array): void {
            // We need to add the requestId so that the client knows which request the
            // message belongs to. The client needs to extract the actual data of which
            // these prepended 8 bytes are not a part of.

            // Create a new buffer larger by 8 bytes - enough to add the requestId
            const buf = new ArrayBuffer(8 + chunk.byteLength);

            // Add the 64 bit Javascript number requestId at the start of the buffer
            const requestIdBytes = new Float64Array(buf, 0, 1);
            requestIdBytes.set([msg.requestId]);

            // Copy the data into the new buffer
            const dataBytes = new Uint8Array(buf, 8);
            dataBytes.set(getUint8Array(chunk));

            sendBuf(new Uint8Array(buf).buffer);
        }

        function onStreamData(chunk: string | ArrayBufferLike | Uint8Array): void {
            if (connection.bufferedAmount > STREAM_HIGH_WATER_MARK) {
                stream.pause();
                setTimeout(resumeWhenBufferDrained, PAUSED_STREAM_CHECK_INTERVAL);
            }

            if (isString(chunk)) {
                onStringStreamData(chunk);
            } else {
                onBinaryStreamData(chunk);
            }
        }

        if (streams.get(msg.requestId)) {
            // This should be impossible, but since the impossible could always happen...
            throw createError('WSRQ-CRSTH1', {id: msg.requestId});
        }

        streams.set(msg.requestId, stream);

        // For string streams: The encoding needs to be sent only in the very first stream response
        // message, because that is when the recipient creates the corresponding write-stream
        let encodingSent = false;

        stream.onData.addListener(onStreamData);

        stream.promise.catch((err: Error) => {
            MessageBus.send('error', err);

            try {
                sendObj({
                    responseId: msg.requestId,
                    type: 'stream-error',
                    error: 'Error while reading the file stream'
                } as MsgResponseStreamErrorObject);
            } catch (_ignore) {
                // Ignored.
            }
        });

        stream.promise.then(
            // If this function throws we will get an unhandled promise rejection, but it really
            // shouldn't happen (famous last words?) - or at least only during development.
            // TODO What if sending the end-of-stream message fails?
            () => {
                streams.delete(msg.requestId);

                sendObj({
                    responseId: msg.requestId,
                    type: 'stream-end'
                } as MsgResponseStreamEndObject);
            },
            // If the stream promise rejected this ensures that the new promise created by then()
            // does not reject. We already have a catch() handler attached separately above.
            _ => undefined
        );
    };
}

/**
 * @private
 * @function
 * @param {EncryptedConnectionInterface} connection - The connection to send results to
 * @param {function(number,number):Function} getServiceById - A function that maps the requested
 * service ID (integer) to a function. The result of the function execution is returned to the
 * communication partner. If the result is a promise we wait for the promise to resolve (or reject).
 * @param {function((MsgRequestTypes|MsgResponseTypes)):undefined} sendObj
 * @param {function(ArrayBuffer):undefined} sendBuf
 * @param {Map<number,SimpleReadStream>} streams - MUTATED! Entries are added and removed.
 * @returns {function(MsgRequestObject):void} Returns a function
 */
function createRequestMsgHandler(
    connection: EncryptedConnectionInterface,
    getServiceById: FindServiceByChannelAndId,
    sendObj: (data: MsgRequestTypes | MsgResponseTypes) => void,
    sendBuf: (data: ArrayBuffer) => void,
    streams: Map<number, SimpleReadStream>
): WebsocketMessageRequestHandler {
    return (msg: MsgRequestTypes): void => {
        // This reports an error on the remote instance in a stream the remote requested from us
        // and that we are in the process of sending. It means the remote has an error that
        // prevents it from handling our response and that we should stop the stream for the
        // given requestId. This message will have been created by websocket-response-handler's
        // createAndRegisterWriteStream function, and in it the stream's error handler.
        if (msg.type === 'write-stream-error') {
            // These special messages use "requestId" so that they end up in the request handler
            // (right here) that serves the requested stream that caused an error.
            const stream = streams.get(msg.requestId);

            if (stream) {
                stream.cancel();
                streams.delete(msg.requestId);
            }

            return;
        }

        const fn = getServiceById(msg.serviceId);

        if (!isFunction(fn)) {
            sendObj({
                responseId: msg.requestId,
                type: 'error',
                error: {
                    name: 'TypeError',
                    message: `Not a function: Servcie ID ${msg.serviceId} [${typeof msg.serviceId}]`,
                    code: UNKNOWN_SERVICE
                }
            } as MsgResponseErrorObject);
            return;
        }

        let rawResult;

        try {
            rawResult = msg.args === undefined ? fn() : fn(...msg.args);
        } catch (err) {
            // Only non-promise results can possibly get here
            rawResult = Promise.reject(err);
        }

        const promiseResult =
            isObject(rawResult) && isFunction(rawResult.then)
                ? (rawResult as Promise<unknown>)
                : Promise.resolve<unknown>(rawResult);

        // This is an event handler: Errors must be handled right here, completely.
        promiseResult
            .then(data => {
                // We interpret this to mean that this is a SimpleReadStream
                if (isSimpleReadStream(data)) {
                    const readStreamHandler = createReadStreamHandler(
                        connection,
                        sendObj,
                        sendBuf,
                        streams
                    );

                    readStreamHandler(msg, data);
                } else if (isObject(data) &&
                    (data instanceof ArrayBuffer ||
                        (isSharedArrayBufferSupported() && data instanceof globalThis.SharedArrayBuffer) ||
                        ('buffer' in data &&
                            (data.buffer instanceof ArrayBuffer ||
                                (isSharedArrayBufferSupported() && data.buffer instanceof globalThis.SharedArrayBuffer))))) {
                    // Is this necessary? Try to catch what could be(come) a common developer error
                    MessageBus.send('error', `Binary data must be sent from a SimpleReadStream; Request: ${JSON.stringify(msg)}`);
                    sendObj({
                        responseId: msg.requestId,
                        type: 'error',
                        error: {
                            name: 'TypeError',
                            message: 'Binary data must be sent from a SimpleReadStream'
                        }
                    });
                } else {
                    sendObj({
                        responseId: msg.requestId,
                        type: 'data',
                        data
                    } as MsgResponseObject);
                }
            })
            .catch(err => {
                MessageBus.send('error', err);

                sendObj({
                    responseId: msg.requestId,
                    type: 'error',
                    error: {
                        name: err.name,
                        message: err.message,
                        code: err.code
                    }
                } as MsgResponseErrorObject);
            });
    };
}

/**
 * Create a handler function for received messages that are requests sent to us
 * @static
 * @param {function(number,number):Function} getServiceByChannelAndId - the requested service ID
 * (integer) to a function. The result of the function execution is returned to the
 * communication partner. If the result is a promise we wait for the promise to resolve (or reject).
 * @param {EncryptedConnectionInterface} connection - The connection to send results to
 * @param {function((MsgRequestTypes|MsgResponseTypes)):undefined} sendObj
 * @param {function(ArrayBuffer):undefined} sendBuf
 * @returns {WebsocketMessageRequestHandler} Returns a {@link WebsocketMessageRequestHandler}
 * function
 */
export function createRequestHandler(
    getServiceByChannelAndId: FindServiceByChannelAndId,
    connection: EncryptedConnectionInterface,
    sendObj: (data: MsgRequestTypes | MsgResponseTypes) => void,
    sendBuf: (data: ArrayBuffer) => void
): WebsocketRequestHandler {
    // INNER SCOPE -- THIS IS PER WEBSOCKET
    // Keep a Map of all ongoing streams in case we have to cancel one
    const streams: Map<number, SimpleReadStream> = new Map();

    /** See {@link WebsocketRequestHandler} */
    function cancelReadStreams(): void {
        streams.forEach((stream, requestId) => {
            if (stream !== null) {
                stream.cancel();
                streams.delete(requestId);
            }
        });
    }

    return {
        requestMsgHandler: createRequestMsgHandler(
            connection,
            getServiceByChannelAndId,
            sendObj,
            sendBuf,
            streams
        ),
        cancelReadStreams
    };
}
